{"ast":null,"code":"const hasProp = prop => obj => obj !== null && typeof obj === \"object\" && prop in obj;\nconst hasMatch = hasProp(\"match\");\nconst chunkExists = chunk => typeof chunk !== \"undefined\";\nfunction clip({\n  curr,\n  next,\n  prev,\n  clipBy = 3\n}) {\n  const words = curr.text.split(\" \");\n  const len = words.length;\n  if (curr.match || clipBy >= len) {\n    return curr.text;\n  }\n  const ellipsis = \"...\";\n  if (chunkExists(next) && chunkExists(prev) && hasMatch(prev) && hasMatch(next)) {\n    if (len > clipBy * 2) {\n      return [...words.slice(0, clipBy), ellipsis, ...words.slice(-clipBy)].join(\" \");\n    }\n    return curr.text;\n  }\n  if (chunkExists(next) && hasMatch(next)) {\n    return [ellipsis, ...words.slice(-clipBy)].join(\" \");\n  }\n  if (chunkExists(prev) && hasMatch(prev)) {\n    return [...words.slice(0, clipBy), ellipsis].join(\" \");\n  }\n  return curr.text;\n}\nconst escapeRegexp = term => term.replace(/[|\\\\{}()[\\]^$+*?.-]/g, char => `\\\\${char}`);\nconst termsToRegExpString = terms => terms.replace(/\\s{2,}/g, \" \").split(\" \").join(\"|\");\nconst regexpQuery = ({\n  terms,\n  matchExactly = false\n}) => {\n  if (typeof terms !== \"string\") {\n    throw new TypeError(\"Expected a string\");\n  }\n  const escapedTerms = escapeRegexp(terms.trim());\n  return `(${matchExactly ? escapedTerms : termsToRegExpString(escapedTerms)})`;\n};\nconst buildRegexp = ({\n  terms,\n  matchExactly = false\n}) => {\n  try {\n    const fromString = /^([/~@;%#'])(.*?)\\1([gimsuy]*)$/.exec(terms);\n    if (fromString) {\n      return new RegExp(fromString[2], fromString[3]);\n    }\n    return new RegExp(regexpQuery({\n      terms,\n      matchExactly\n    }), \"ig\");\n  } catch {\n    throw new TypeError(\"Expected terms to be either a string or a RegExp!\");\n  }\n};\nlet IDX = 36;\nlet HEX = \"\";\nwhile (IDX--) {\n  HEX += IDX.toString(36);\n}\nfunction uid(len = 11) {\n  let str = \"\";\n  let num = len;\n  while (num--) {\n    str += HEX[Math.random() * 36 | 0];\n  }\n  return str;\n}\nconst hasLength = str => str.length > 0;\nconst highlightWords = ({\n  text,\n  query,\n  clipBy,\n  matchExactly = false\n}) => {\n  const safeQuery = typeof query === \"string\" ? query.trim() : query;\n  if (safeQuery === \"\") {\n    return [{\n      key: uid(),\n      text,\n      match: false\n    }];\n  }\n  const searchRegexp = buildRegexp({\n    terms: query,\n    matchExactly\n  });\n  return text.split(searchRegexp).filter(hasLength).map(str => ({\n    // Compose the object for a match\n    key: uid(),\n    text: str,\n    match: matchExactly ? str.toLowerCase() === safeQuery.toLowerCase() : searchRegexp.test(str)\n  })).map((chunk, index, chunks) => ({\n    // For each chunk, clip the text if needed\n    ...chunk,\n    // All the props first\n    ...(typeof clipBy === \"number\" && {\n      // We only overwrite the text if there is a clip\n      text: clip({\n        curr: chunk,\n        // We need the current chunk\n        ...(index < chunks.length - 1 && {\n          next: chunks[index + 1]\n        }),\n        // If this wasn't the last chunk, set the next chunk\n        ...(index > 0 && {\n          prev: chunks[index - 1]\n        }),\n        // If this wasn't the first chunk, set the previous chunk\n        clipBy\n      })\n    })\n  }));\n};\nexport { highlightWords as default };","map":{"version":3,"names":["hasProp","prop","obj","hasMatch","chunkExists","chunk","clip","curr","next","prev","clipBy","words","text","split","len","length","match","ellipsis","slice","join","escapeRegexp","term","replace","char","termsToRegExpString","terms","regexpQuery","matchExactly","TypeError","escapedTerms","trim","buildRegexp","fromString","exec","RegExp","IDX","HEX","toString","uid","str","num","Math","random","hasLength","highlightWords","query","safeQuery","key","searchRegexp","filter","map","toLowerCase","test","index","chunks","default"],"sources":["/Users/kamisama/PycharmProjects/quant/asset_tracking/frontend/node_modules/highlight-words/dist/highlight-words.mjs"],"sourcesContent":["const hasProp = (prop) => (obj) => obj !== null && typeof obj === \"object\" && prop in obj;\nconst hasMatch = hasProp(\"match\");\nconst chunkExists = (chunk) => typeof chunk !== \"undefined\";\nfunction clip({\n  curr,\n  next,\n  prev,\n  clipBy = 3\n}) {\n  const words = curr.text.split(\" \");\n  const len = words.length;\n  if (curr.match || clipBy >= len) {\n    return curr.text;\n  }\n  const ellipsis = \"...\";\n  if (chunkExists(next) && chunkExists(prev) && hasMatch(prev) && hasMatch(next)) {\n    if (len > clipBy * 2) {\n      return [\n        ...words.slice(0, clipBy),\n        ellipsis,\n        ...words.slice(-clipBy)\n      ].join(\" \");\n    }\n    return curr.text;\n  }\n  if (chunkExists(next) && hasMatch(next)) {\n    return [ellipsis, ...words.slice(-clipBy)].join(\" \");\n  }\n  if (chunkExists(prev) && hasMatch(prev)) {\n    return [...words.slice(0, clipBy), ellipsis].join(\" \");\n  }\n  return curr.text;\n}\n\nconst escapeRegexp = (term) => term.replace(/[|\\\\{}()[\\]^$+*?.-]/g, (char) => `\\\\${char}`);\nconst termsToRegExpString = (terms) => terms.replace(/\\s{2,}/g, \" \").split(\" \").join(\"|\");\nconst regexpQuery = ({\n  terms,\n  matchExactly = false\n}) => {\n  if (typeof terms !== \"string\") {\n    throw new TypeError(\"Expected a string\");\n  }\n  const escapedTerms = escapeRegexp(terms.trim());\n  return `(${matchExactly ? escapedTerms : termsToRegExpString(escapedTerms)})`;\n};\nconst buildRegexp = ({\n  terms,\n  matchExactly = false\n}) => {\n  try {\n    const fromString = /^([/~@;%#'])(.*?)\\1([gimsuy]*)$/.exec(terms);\n    if (fromString) {\n      return new RegExp(fromString[2], fromString[3]);\n    }\n    return new RegExp(regexpQuery({ terms, matchExactly }), \"ig\");\n  } catch {\n    throw new TypeError(\"Expected terms to be either a string or a RegExp!\");\n  }\n};\n\nlet IDX = 36;\nlet HEX = \"\";\nwhile (IDX--) {\n  HEX += IDX.toString(36);\n}\nfunction uid(len = 11) {\n  let str = \"\";\n  let num = len;\n  while (num--) {\n    str += HEX[Math.random() * 36 | 0];\n  }\n  return str;\n}\n\nconst hasLength = (str) => str.length > 0;\nconst highlightWords = ({\n  text,\n  query,\n  clipBy,\n  matchExactly = false\n}) => {\n  const safeQuery = typeof query === \"string\" ? query.trim() : query;\n  if (safeQuery === \"\") {\n    return [\n      {\n        key: uid(),\n        text,\n        match: false\n      }\n    ];\n  }\n  const searchRegexp = buildRegexp({ terms: query, matchExactly });\n  return text.split(searchRegexp).filter(hasLength).map((str) => ({\n    // Compose the object for a match\n    key: uid(),\n    text: str,\n    match: matchExactly ? str.toLowerCase() === safeQuery.toLowerCase() : searchRegexp.test(str)\n  })).map((chunk, index, chunks) => ({\n    // For each chunk, clip the text if needed\n    ...chunk,\n    // All the props first\n    ...typeof clipBy === \"number\" && {\n      // We only overwrite the text if there is a clip\n      text: clip({\n        curr: chunk,\n        // We need the current chunk\n        ...index < chunks.length - 1 && { next: chunks[index + 1] },\n        // If this wasn't the last chunk, set the next chunk\n        ...index > 0 && { prev: chunks[index - 1] },\n        // If this wasn't the first chunk, set the previous chunk\n        clipBy\n      })\n    }\n  }));\n};\n\nexport { highlightWords as default };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}